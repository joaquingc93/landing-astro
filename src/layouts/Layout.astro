---
import SEOHead from '@/components/SEOHead.astro';
import '@/styles/global.css';

export interface Props {
  title?: string;
  description?: string;
  canonical?: string;
  image?: string;
  noindex?: boolean;
  type?: 'website' | 'article' | 'service';
  publishedTime?: string;
  modifiedTime?: string;
  schema?: any;
  class?: string;
}

const {
  title,
  description,
  canonical,
  image,
  noindex,
  type,
  publishedTime,
  modifiedTime,
  schema,
  class: className = ''
} = Astro.props;
---

<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
  <head>
    <SEOHead
      title={title}
      description={description}
      canonical={canonical}
      image={image}
      noindex={noindex}
      type={type}
      publishedTime={publishedTime}
      modifiedTime={modifiedTime}
      schema={schema}
    />
    
    <!-- View Transitions API -->
    <meta name="view-transition" content="same-origin" />
    
    <!-- Performance optimization -->
    <link rel="preload" href="/fonts/inter-var.woff2" as="font" type="font/woff2" crossorigin />
    <link rel="preload" href="/fonts/playfair-display-var.woff2" as="font" type="font/woff2" crossorigin />
    
    <!-- Critical resources -->
    <style>
      /* Critical CSS for first paint */
      body {
        font-family: Inter, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        line-height: 1.6;
        color: #0f172a;
        background-color: #ffffff;
      }
      
      /* Loading states */
      .page-loading {
        opacity: 0;
        transform: translateY(20px);
        transition: all 0.3s ease-out;
      }
      
      .page-loaded {
        opacity: 1;
        transform: translateY(0);
      }
      
      /* Prevent flash of unstyled content */
      .hero-section {
        min-height: 60vh;
        background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      /* Skip to content link for accessibility */
      .skip-link {
        position: absolute;
        top: -40px;
        left: 6px;
        background: #2563eb;
        color: white;
        padding: 8px;
        text-decoration: none;
        z-index: 100;
        border-radius: 4px;
        transition: top 0.3s;
      }
      
      .skip-link:focus {
        top: 6px;
      }
      
      /* Focus management */
      .focus-visible {
        outline: 2px solid #2563eb;
        outline-offset: 2px;
      }
      
      /* Smooth scrolling for reduced motion users */
      @media (prefers-reduced-motion: reduce) {
        html {
          scroll-behavior: auto;
        }
        
        *,
        *::before,
        *::after {
          animation-duration: 0.01ms !important;
          animation-iteration-count: 1 !important;
          transition-duration: 0.01ms !important;
        }
      }
      
      /* High contrast mode support */
      @media (prefers-contrast: high) {
        * {
          border-color: ButtonText;
        }
      }
    </style>
  </head>
  
  <body class={`min-h-screen bg-white text-neutral-900 ${className} page-loading`}>
    <!-- Skip to main content link for accessibility -->
    <a href="#main-content" class="skip-link">
      Skip to main content
    </a>
    
    <!-- Page wrapper -->
    <div id="page-wrapper" class="flex flex-col min-h-screen">
      <!-- Main content area -->
      <main id="main-content" class="flex-1" tabindex="-1">
        <slot />
      </main>
    </div>
    
    <!-- Scripts -->
    <script>
      // Page loading management
      document.addEventListener('DOMContentLoaded', () => {
        document.body.classList.remove('page-loading');
        document.body.classList.add('page-loaded');
      });
      
      // View Transitions API support detection
      if (document.startViewTransition) {
        document.documentElement.classList.add('view-transitions');
      }
      
      // Performance observer for Core Web Vitals
      if ('PerformanceObserver' in window) {
        try {
          // Observe LCP
          new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
              if (entry.entryType === 'largest-contentful-paint') {
                console.log('LCP:', entry.startTime);
              }
            }
          }).observe({ entryTypes: ['largest-contentful-paint'] });
          
          // Observe FID
          new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
              if (entry.entryType === 'first-input') {
                console.log('FID:', entry.processingStart - entry.startTime);
              }
            }
          }).observe({ entryTypes: ['first-input'] });
          
          // Observe CLS
          new PerformanceObserver((list) => {
            let clsValue = 0;
            for (const entry of list.getEntries()) {
              if (!entry.hadRecentInput) {
                clsValue += entry.value;
              }
            }
            console.log('CLS:', clsValue);
          }).observe({ entryTypes: ['layout-shift'] });
        } catch (error) {
          console.warn('Performance monitoring not available:', error);
        }
      }
      
      // Enhanced focus management
      let hadKeyboardEvent = true;
      let keyboardThrottleTimeout;
      
      const keyboardUsed = () => {
        hadKeyboardEvent = true;
      };
      
      const mouseUsed = (event) => {
        if (hadKeyboardEvent) {
          hadKeyboardEvent = false;
        }
      };
      
      document.addEventListener('keydown', keyboardUsed, true);
      document.addEventListener('mousedown', mouseUsed, true);
      
      // Add focus-visible class for better focus management
      document.addEventListener('focusin', (event) => {
        if (hadKeyboardEvent || event.target.matches(':focus-visible')) {
          event.target.classList.add('focus-visible');
        }
      });
      
      document.addEventListener('focusout', (event) => {
        event.target.classList.remove('focus-visible');
      });
      
      // Intersection Observer for animations
      if ('IntersectionObserver' in window) {
        const animationObserver = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              entry.target.classList.add('animate-fade-in');
              animationObserver.unobserve(entry.target);
            }
          });
        }, {
          threshold: 0.1,
          rootMargin: '0px 0px -50px 0px'
        });
        
        // Observe elements with animation classes
        document.addEventListener('DOMContentLoaded', () => {
          document.querySelectorAll('.animate-on-scroll').forEach((el) => {
            animationObserver.observe(el);
          });
        });
      }
      
      // Error boundary for client-side errors
      window.addEventListener('error', (event) => {
        console.error('Client error:', event.error);
        // Optional: Send to analytics service
      });
      
      window.addEventListener('unhandledrejection', (event) => {
        console.error('Unhandled promise rejection:', event.reason);
        // Optional: Send to analytics service
      });
      
      // Page visibility API for performance tracking
      if ('visibilityState' in document) {
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'hidden') {
            // Page is hidden, could be a good time to save state
          } else if (document.visibilityState === 'visible') {
            // Page is visible again
          }
        });
      }
    </script>
    
    <!-- Critical third-party scripts -->
    <script is:inline>
      // Polyfills for older browsers
      if (!window.IntersectionObserver) {
        const script = document.createElement('script');
        script.src = 'https://polyfill.io/v3/polyfill.min.js?features=IntersectionObserver';
        document.head.appendChild(script);
      }
    </script>
  </body>
</html>