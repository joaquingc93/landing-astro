---
import SEOHead from '@/components/SEOHead.astro';
import FloatingWhatsApp from '@/components/FloatingWhatsApp.astro';
import Footer from '@/components/Footer.astro';
// Import global Tailwind layers so a real CSS asset is generated in production
// (previously only critical inline CSS existed, causing missing stylesheet 404s)
import '@/styles/global.css';

export interface Props {
  title?: string;
  description?: string;
  canonical?: string;
  image?: string;
  noindex?: boolean;
  type?: 'website' | 'article' | 'service';
  publishedTime?: string;
  modifiedTime?: string;
  schema?: any;
  schemas?: any[]; // multiple schemas
  class?: string;
  hideWhatsApp?: boolean;
}

const {
  title,
  description,
  canonical,
  image,
  noindex,
  type,
  publishedTime,
  modifiedTime,
  schema,
  schemas,
  class: className = '',
  hideWhatsApp = false
} = Astro.props as Props;
---

<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
  <head>
    <SEOHead
      title={title}
      description={description}
      canonical={canonical}
      image={image}
      noindex={noindex}
      type={type}
      publishedTime={publishedTime}
      modifiedTime={modifiedTime}
      schema={schema}
      schemas={schemas}
    />
    
    <!-- View Transitions API -->
    <meta name="view-transition" content="same-origin" />
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Playfair+Display:wght@400..900&display=swap" rel="stylesheet" />
    
    <!-- Minimal inline CSS (rest is in global.css bundle) -->
    <style>
      /* Minimal reset subset */
      *,::before,::after{box-sizing:border-box;}
      body{margin:0;}
      /* Loading state fade-in */
      .page-loading{opacity:0;transform:translateY(12px);transition:all .25s ease-out;}
      .page-loaded{opacity:1;transform:translateY(0);}
      /* Accessible skip link */
      .skip-link{position:absolute;top:-40px;left:6px;background:#2563eb;color:#fff;padding:8px;border-radius:4px;text-decoration:none;z-index:100;transition:top .25s;}
      .skip-link:focus{top:6px;}
      /* Reduce motion respect */
      @media (prefers-reduced-motion:reduce){.page-loading,.page-loaded{transition:none !important;}}
    </style>
  </head>
  
  <body class={`min-h-screen bg-white text-neutral-900 ${className} page-loading`}>
    <!-- Skip to main content link for accessibility -->
    <a href="#main-content" class="skip-link">
      Skip to main content
    </a>
    
    <!-- Page wrapper -->
    <div id="page-wrapper" class="flex flex-col min-h-screen">
      <!-- Main content area -->
      <main id="main-content" class="flex-1" tabindex="-1">
        <slot />
      </main>
      <!-- Global Footer -->
      <Footer />
    </div>
    
  <!-- Floating WhatsApp Button (optional) -->
  { !hideWhatsApp && <FloatingWhatsApp /> }
    
    <!-- Scripts -->
    <script>
      // Page loading management
      document.addEventListener('DOMContentLoaded', () => {
        document.body.classList.remove('page-loading');
        document.body.classList.add('page-loaded');
      });
      
      // View Transitions API support detection (guarded)
      try {
        if ('startViewTransition' in document) {
          document.documentElement.classList.add('view-transitions');
        }
      } catch {}
      
      // Performance observer for Core Web Vitals (with defensive casting)
      try {
        if ('PerformanceObserver' in window) {
          // Largest Contentful Paint
          new PerformanceObserver((list) => {
            list.getEntries().forEach((entry) => {
              if (entry.entryType === 'largest-contentful-paint') {
                console.log('LCP:', entry.startTime);
              }
            });
          }).observe({ entryTypes: ['largest-contentful-paint'] });

          // First Input Delay (legacy)
          new PerformanceObserver((list) => {
            list.getEntries().forEach((entry) => {
              if (entry.entryType === 'first-input') {
                const anyEntry: any = entry;
                if (typeof anyEntry.processingStart === 'number') {
                  console.log('FID:', anyEntry.processingStart - entry.startTime);
                }
              }
            });
          }).observe({ entryTypes: ['first-input'] });

          // Cumulative Layout Shift
            new PerformanceObserver((list) => {
            let clsValue = 0;
            list.getEntries().forEach((entry) => {
              const anyEntry: any = entry;
              if (anyEntry.entryType === 'layout-shift' && !anyEntry.hadRecentInput) {
                if (typeof anyEntry.value === 'number') {
                  clsValue += anyEntry.value;
                }
              }
            });
            console.log('CLS:', clsValue);
          }).observe({ entryTypes: ['layout-shift'] });
        }
      } catch (error) {
        console.warn('Performance monitoring not available:', error);
      }
      
      // Enhanced focus management
      let hadKeyboardEvent = true;
      const keyboardUsed = () => { hadKeyboardEvent = true; };
      const mouseUsed = () => { if (hadKeyboardEvent) { hadKeyboardEvent = false; } };
      
      document.addEventListener('keydown', keyboardUsed, true);
      document.addEventListener('mousedown', mouseUsed, true);
      
      // Add focus-visible class for better focus management
      document.addEventListener('focusin', (event: Event) => {
        const target = event.target as HTMLElement | null;
        if (!target) return;
        if (hadKeyboardEvent || (target.matches && target.matches(':focus-visible'))) {
          target.classList.add('focus-visible');
        }
      });
      
      document.addEventListener('focusout', (event: Event) => {
        const tgt = event.target;
        if (tgt && (tgt as any).classList) {
          (tgt as HTMLElement).classList.remove('focus-visible');
        }
      });
      
      // Intersection Observer for animations
      if ('IntersectionObserver' in window) {
        const animationObserver = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              entry.target.classList.add('animate-fade-in');
              animationObserver.unobserve(entry.target);
            }
          });
        }, {
          threshold: 0.1,
          rootMargin: '0px 0px -50px 0px'
        });
        
        // Observe elements with animation classes
        document.addEventListener('DOMContentLoaded', () => {
          document.querySelectorAll('.animate-on-scroll').forEach((el) => {
            animationObserver.observe(el);
          });
        });
      }
      
      // Error boundary for client-side errors
      window.addEventListener('error', (event) => {
        console.error('Client error:', event.error);
        // Optional: Send to analytics service
      });
      
      window.addEventListener('unhandledrejection', (event) => {
        console.error('Unhandled promise rejection:', event.reason);
        // Optional: Send to analytics service
      });
      
      // Page visibility API for performance tracking
      if ('visibilityState' in document) {
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'hidden') {
            // Page is hidden, could be a good time to save state
          } else if (document.visibilityState === 'visible') {
            // Page is visible again
          }
        });
      }
    </script>
    
    <!-- Critical third-party scripts -->
    <script is:inline>
      // Polyfills for older browsers
      if (!window.IntersectionObserver) {
        const script = document.createElement('script');
        script.src = 'https://polyfill.io/v3/polyfill.min.js?features=IntersectionObserver';
        document.head.appendChild(script);
      }
    </script>
  </body>
</html>